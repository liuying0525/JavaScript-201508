<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
/*function Fn(){
    var num = 10;
    this.x= 100;//这个this是f1
    this.getX = function () {
        console.log(this.x);//this需要看getX执行的时候才知道
    }
}
var f1=new Fn;//不需要传参括号可以省略。
    //在构造函数模式中 new Fn（） 执行，如果Fn不需要传递参数的话，后面的小括号可以省略。
    //2,this的问题：
    f1.getX();//this是f1,因为。前面是f1
    var ss = f1.getX;
    ss();//this是window,因为ss前面没有.
    console.log(f1.num);//undefined 因为num不是它的属性，而是个变量。
    //3，类有普通函数的一面，当函数执行的时候 ，var num其实只是当前形成的私有作用域中的私有变量而已，它和我们的f1这个实例没有任何关系，只有this.xxx=xxxx才相当于给f1这个实例增加私有的属性和方法，才和我们的f1有关系。。*/
    //4,在构造函数模式中，浏览器会默认的把我们的实例返回（返回的是一个对象数据类型的值）；如果我们自己手动写了return返回:
//返回的是一个基本数据类型的值，当前实例是不变的，例如：
//5,检测某一个实例是否属于这个类-》instanceof
console.log(f1 instanceof  Fn);//true
console.log(f1 instanceof Arry);//false
    console.log(f1 instanceof object)//true 因为每个实例都是object类型

    //对于检测检测数据类型来说，typeof有自己的局限性，不能细分object下的对象
    var a = =[];
    consolelog(a instance of Arry);
    //构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立开的-》实例识别
    //基于构造函数模式的原理模式解决了， 方法或者属性公有的问题-》把实例之间相同的属性和方法提取成

    //1.每一个函数数据类型(普通函数，类）都有一个天生自带的属性：prototype(原型），并且这个属性是一个对象数据类型的值
    //2,并且在prototype上浏览器天生给它加了一个属性constructor(构造函数），属性值是当前函数（类）本身
    //3,每个对象数据类型（普通的对象，实例，prototype...）也天生自带一个属性：_proto_,属性值是当前实例所属类的原型（prototype）
    function Fn(){
        this.x  = 100;
    }
    Fn.prototype.getX = function(){
        console.log(this.x);
    }
    var f1=new Fn;
    var f2 = new Fn;

//object是JS中所有对象数据类型的基类（最顶层的类）
 //1,f1 instanceof object of ->true 因为f1通过_proto_可以向上级查找，不管有多少级，最后总能找到objdect

 //2，在object.prototype上没有_proto_这个属性
    f1.hasOwnProperty("x");
    //但是我们发现在f1的私有属性上并没有这个方法，那如何处理的呢？
    //1)通过 对象名.属性名 的方式获取属性值的时候，首先在对象的私有的属性上进行查找，如果私有中存在这个属性，则获取的是私有的属性值
    //如果私有的没有，则通过_proto_找到所属类的原型（类的原型上定义的属性和方法都是当前实例共有的属性和方法），原型上存在的话，获取的是共有的属性值；
    //如果原型上也没有，则继续通过原型上的_proto_继续向上查找，一直找到object的prototype为止，这种查找的机制就是我们的“原型链机制”就是我们的原型链模式




</script>
</body>
</html>