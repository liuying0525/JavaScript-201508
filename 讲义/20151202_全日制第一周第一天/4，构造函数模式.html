<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    function createJsPerson(name,age) {
        var obj = {};
        obj.name = name;
        obj.age = age;
        obj.writeJs = function () {
            console.log("my name is" + this.name + ",i can write js 啦~~");
        }
     return obj;
    }

    var p1=createJsPerson("尹华芝",18);
    p1.writeJs();

    //构造函数模式的目的就是为了创建一个自定义类，并创建这个类的实例。
    //构造函数模式和工厂模式的区别？
    //1,执行的时候
    //普通函数执行->createJsPerson()
    //构造函数模式->new createJsPerson()    不叫函数名了，叫类名  通过new执行后，我们的CreateJsPerson就是一个类了。内置类的的首字母大写。创造类的话首字母都要大写，约定俗成。
    //而函数执行的返回值P1就是CreateJsPerson这个类的一个实例




    //创建一个数组：
    var ary=[];//字面量方式
    var ary=new Array()//实例创建的方式-》构造函数模式执行的方式。
    //不管哪种方式ary都是Array这个类的一个实例。
    //在JS中所有的类都是函数数据类型的。它通过new执行就变成了一个类，但是它本身也是一个普通的函数。
    //JS当中所有的实例都是对象数据类型的。
    //1,在函数代码执行的时候
    //相同：都是形成一个私有的作用域，然后形参赋值，预解释，代码开始从上往下执行（类和普通函数一样，也有普通函数的一面）
    //不同：在代码执行之前，不用自己再手动的创建对象了，浏览器会默认的创建一个对象数据类型的值（这个对象其实就是我们当前类的一个实例）
    //接下来代码从上到下执行，以当前实例为执行的主体，this代表的就是当前的实例，然后分别的把属性名和属性值赋值
    //给当前的实例
    //浏览器再把创建的实例默认的进行返回。
    //2，在构造函数模式中，类中（函数体中）出现的this.xxx=xxxx中的this是当前类的一个实例
    //3,p1和P2都是CreteJsperson这个类的实例，所以都拥有writeJs这个方法，但是不同实例之间的方法是不一样的
    //在类中给实例增加的属性（this.xxx=xxx）属于当前实例的私有的属性，实例和实例之间是单独的个体，所以私有的属性之间是不相等的。
    var res=CreatePerson("珠峰",13);//这样写不是构造函数模式执行而是普通函数执行，由于没有写return,所以res=undefined,并且



</script>
</body>
</html>